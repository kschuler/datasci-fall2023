{
  "hash": "558bf35e370ce8d2996a7e7c7eb3685d",
  "result": {
    "markdown": "---\ntitle: \"Hypothesis testing\"\nsubtitle: \"Data Science for Studying Language and the Mind\"\nauthor: Katie Schuler\ndate: 09-26-2023\necho: true\nformat: \n    revealjs:\n        theme: dark\n        slide-number: true\n        incremental: true \n        footer: \"[https://kathrynschuler.com/datasci](https://kathrynschuler.com/datasci/)\"\n---\n\n::: {.cell}\n\n:::\n\n\n# Explore a more complex dataset \n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n## Last week: single quantity\n\nWe explored brain volume \n\n\n::: {.cell}\n\n```{.r .cell-code}\npenn_sample %>%\n  ggplot(aes(x = volume)) +\n  geom_histogram(color = \"gray\")\n```\n\n::: {.cell-output-display}\n![](hypothesis-testing_files/figure-revealjs/unnamed-chunk-3-1.png){width=960}\n:::\n:::\n\n\n## This week: two quantities\n\nBrain volume AND sex \n\n## Visualize with boxplot {.smaller}\n\nA useful visualization for a categorical variable is a boxplot: \n\n\n::: {.cell}\n\n```{.r .cell-code}\npenn_sample %>%\n  ggplot(aes(y = volume, x = sex)) +\n  geom_boxplot(aes(color = sex))\n```\n\n::: {.cell-output-display}\n![](hypothesis-testing_files/figure-revealjs/unnamed-chunk-4-1.png){width=960}\n:::\n:::\n\n\n## Observed difference in means {.smaller}\n\nDo the two sexes differ in mean brain volume?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobs_diff <- penn_sample %>% \n  specify(response = volume, explanatory = sex) %>%\n  calculate(stat = \"diff in means\", order = c(\"male\", \"female\"))\n\nobs_diff\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nResponse: volume (numeric)\nExplanatory: sex (factor)\n# A tibble: 1 × 1\n   stat\n  <dbl>\n1  19.2\n```\n:::\n:::\n\n\n## Observed difference in means {.smaller}\n\nSampling variability or true difference in means?\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](hypothesis-testing_files/figure-revealjs/unnamed-chunk-6-1.png){width=960}\n:::\n:::\n\n\n\n# Hypothesis testing framework\n\n## 3-step process {.smaller}\n\nTo determine whether the brains of male and female Penn students differ with respect to the mean, we can use a framework for decision making called **hypothesis testing**. \n\n1. First we pose a **null hypothesis** that our result is due to nothing but chance (sampling variability)\n2. Then we ask: if the null hypothesis is true, how likely is our observed pattern of results? This liklihood is the **p-value**. \n3. Finally, if the p-value is less some threshold we decide upon (<0.05) then we **reject** the null hypothesis.\n\n## Step 1: Pose the null hypothesis {.smaller}\n\nWe pose a null hypothesis for practical reasons: it is the hypothesis for which we can simulate data. We can construct the sampling distribution for a hypothetical world in which our observed value is due to chance (we call this the **null distribution**). \n\n- To construct the null distribution we can use a process called **randomization**. \n- Randomization is similar to bootstrapping except, on each repeat, we will shuffle the sex and randomly assigning it to each participant. \n- This simulates a world in which there is no relationship between brain volume and sex.\n\n## Step 1: Pose the null hypothesis {.smaller}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](hypothesis-testing_files/figure-revealjs/unnamed-chunk-7-1.png){width=960}\n:::\n:::\n\n\n## Step 2: How likely is our observed pattern? {.smaller}\n\nIf the null hypothesis is true, how likely is our observed pattern of results? \n\n- We can quantify this liklihood directly with the p-value: count the number of values in our null distribution that are more extreme than our observed value and divide that by the number of simulations we generated. \n\n. . . \n\n::: {.cell}\n\n```{.r .cell-code}\nnull_distribution %>% \n  filter(abs(stat) > obs_diff$stat) %>%\n  summarise(p = n()/1000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n      p\n  <dbl>\n1  0.24\n```\n:::\n:::\n\n\n## Step 2: How likely is our observed pattern? {.smaller}\n\nOr `infer` can handle this for us with the `get_p_value()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnull_distribution %>%\n  get_p_value(obs_stat = obs_diff, direction = \"both\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  p_value\n    <dbl>\n1   0.242\n```\n:::\n:::\n\n\n- A large p-value means our observed value is very likely under the null hypotheisis. \n- A small p-value means our observed value is very unlikely under the null hypothsis. \n\n## Step 2: How likely is our observed pattern? {.smaller}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](hypothesis-testing_files/figure-revealjs/unnamed-chunk-10-1.png){width=960}\n:::\n:::\n\n\n## Step 3: Decide whether to reject {.smaller}\n\nFinally, if the p-value is small enough — less than some threshold we decide upon — we reject the null hypothesis. By convention we consider a p-value less than 0.05 to be implausible enough that we can reject the null hypothesis. \n\n\n::: {.cell}\n::: {.cell-output-display}\n![](hypothesis-testing_files/figure-revealjs/unnamed-chunk-11-1.png){width=960}\n:::\n:::\n\n\n## Step 3: Decide whether to reject {.smaller}\n\nNote that obtaining our observed value is *implausible* under the null, but not *impossible*. In other words, our decision to reject (or not) could be wrong!\n\n- When we reject a null hypothesis that was actually true, we call it a **type I error**.\n- When we fail to reject a null hypothesis that was actually false, we call it a **type II error** \n\n## Remembering the error types {.smaller}\n\n![This figure borrowed from reddit can help you remember the error types. (Null hypothesis here is \"NOT pregnant\")](/include/figures/type1-type2-errors.png)\n\n# Demo the whole process\n\n# There is only one test\n\n## There is only one test {.smaller}\n\nIf you understand this framework, you can understand any hypothesis test (t-test, chi-squared, etc).\n\n![Figure borrowed from Modern Dive textbook](/include/figures/one-test.png){fig-align=\"center\" width=50%}\n\n\n## Two ways to simulate data {.smaller}\n\nRemember from last week that there are two ways we can construct a sampling distribution (simulate data):\n\n1. **Nonparametrically**, via brute computational force (simulating many repeats of the same experiment with bootstrapping or randomization) \n2. **Parametrically**, by assuming the data were sampled from known probability distribution and working out what happens theoretically under that distribution. \n\n## Demo with t-test \n\n# Exploring relationships\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(languageR)\n```\n:::\n\n\n## Visualize with scatter plot {.smaller}\n\nWe can explore the relationship between two quantities visually with a **scatter plot**.\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nratings %>% \n  ggplot(aes(x = Frequency, y = meanFamiliarity)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](hypothesis-testing_files/figure-revealjs/unnamed-chunk-13-1.png){width=960}\n:::\n:::\n\n\n## Possible relationships {.smaller}\n\nIf there is no relationship between the variables, we say they are **independent**: knowing the value of one variable provides no information about the other variable.\n\n. . . \n\nIf there *is* some relationship between the variables, we can consider two types:\n\n1. There may be a **linear relationship** between the variables. When one goes up the other goes up (positive) or when one goes up the other goes down (negative). \n2. Or a **nonlinear relationship**. Nonlinear is a very broad category that encompasses all relationships that are not linear (e.g. a U-shaped curve).\n\n# Correlation\n\n## Correlation {.smaller}\n\nOne way to quantify linear relationships is with **correlation ($r$)**. Correlation expresses the linear relationship as a range from -1 to 1, where -1 means the relationship is perfectly negative and 1 means the relationship is perfectly positive. \n\n![Figure borrowed from iStock photos](/include/figures/correlation.jpeg){fig-align=\"center\" width=50%}\n\n## Correlation formally {.smaller}\n\nCorrelation can be calculated by taking the z-score of each variable (a normalization technique in which we subtract the mean and divide by the standard deviation) and then computing the average product of each variable: \n\n$r=\\frac{\\sum_{i=1}^n (\\frac{x_i - \\bar{x}}{sd(x)})(\\frac{y_i - \\bar{y}}{sd(y)})}{n}$\n\n## Correlation with R {.smaller}\n\nOr we can use R's built in correlation function: `cor(x,y)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncor(ratings$Frequency, ratings$meanFamiliarity)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.4820286\n```\n:::\n:::\n\n\n## Correlation and sampling variability\n\nJust like the mean — and all other test statistics! — *$r$* is subject to sampling variability. We can indicate our uncertainty around the correlation we observe in the same way we did for the mean last week: construct the sampling distribution of the correlation via bootstrapping and compute a confidence interval. \n\n## Correlation and hypothesis testing\n\nHow do we test whether the correlation we observed in the data is significantly different from zero? We can use hypothesis testing (as learned today)! Here our null hypothesis that there is no relationship between the variables (they are **independent**). \n\n# Demo with correlation",
    "supporting": [
      "hypothesis-testing_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}