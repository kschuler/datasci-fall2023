{
  "hash": "c9231b4e81302e4e8c7f23e18ae3b29f",
  "result": {
    "markdown": "---\ntitle: \"Data Importing\"\nsubtitle: \"Data Science for Studying Language and the Mind\"\nauthor: Katie Schuler\ndate: 09-05-2023\necho: true\nformat: \n    revealjs:\n        theme: dark\n        incremental: true \n        footer: \"[https://kathrynschuler.com/datasci](https://kathrynschuler.com/datasci/)\"\n---\n\n## Problem Set 1  {.smaller}\n\n- due Sunday 11:59pm\n- Get support by: \n    - Asking specific Qs on Ed\n    - Come to office hours \n    - Get a pset buddy\n- But we will `not`:\n    - Answer \"is this correct?\"\n    - Give feedback on your entire pset before deadline\n    - Go over the pset in lab \n\n## Last week \n\n- Basic concepts\n- Important functions\n- Vectors \n- Operations\n- [Subsetting](https://kathrynschuler.com/datasci/slides/r-basics.html#/ways-to-extract-a-single-element) - stopped here \n- Built-in functions\n- Missing values\n- Programming\n\n## You are `here` {.smaller} \n\n:::: {.columns}\n\n::: {.column width=\"33%\"}\n\n##### Data science with R \n::: {.nonincremental}\n- Hello, world!\n- R basics\n- `Data importing`\n- Data visualization \n- Data wrangling \n:::\n:::\n\n::: {.column width=\"33%\"}\n\n##### Stats & Model buidling\n::: {.nonincremental}\n- Probability distributions\n- Sampling variability\n- Hypothesis testing\n- Model specification\n- Model fitting \n- Model accuracy\n- Model reliability\n:::\n:::\n\n::: {.column width=\"33%\"}\n\n##### More advanced \n::: {.nonincremental}\n\n- Classification\n- Feature engineering (preprocessing) \n- Inference for regression\n- Mixed-effect models\n::: \n:::\n\n::::\n\n## Overview for today\n\n- Tidyverse\n- Tidy data \n- `purr`  - functional programming\n- `tibble` - modern data.frame\n- `readr` - reading data\n\n# Tidyverse \n> The tidyverse is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures. \n> \n> [Tidyverse package docs](https://www.tidyverse.org/)\n\n## Tidyverse {.smaller}\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n- `ggplot2` - for data visualization\n- `dplyr` - for data wrangling\n- `readr` - for reading data\n- `tibble` - for modern data frames\n- `stringr`: for string manipulation\n- `forcats`: for dealing with factors\n- `tidyr`: for data tidying\n- `purrr`: for functional programming\n:::\n\n::: {.column width=\"50%\"}\n\n![Tidyverse hex logos from www.tidyverse.org](/include/figures/tidyverse-hexlogos.png){#fig-tidyverse fig-align=\"center\" width=100%}\n:::\n\n::::\n\n## Loading the tidyverse\n\nAlready installed on Google Colab's R kernel:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\nMessage: \n\n- a list of packages loaded\n- a warning of potential name conflicts \n \n\n## Tidy data\n\nTidyverse makes use of tidy data, a standard way of structuring datasets: \n\n1. each variable forms a **column**; each column forms a variable\n2. each observation forms a **row**; each row forms an observation\n3. value is a **cell**; each cell is a single value\n\n## Tidy data {.smaller}\n\n![Visual of tidy data rules, from R for Data Science](/include/figures/tidy-data.png){#fig-tidydata fig-align=\"center\" width=80%}\n\nWhy tidy data? \n\n- Because consistency and uniformity are very helpful when programming\n- Variables as columns works well for vectorized languages (R!)\n\n\n# `purr`\nFunctional programming\n\nto illustrate the joy of `tidyverse` and tidy data\n\n## `purr`\n\n> purrr enhances R’s functional programming (FP) toolkit by providing a complete and consistent set of tools for working with functions and vectors. If you’ve never heard of FP before, the best place to start is the family of map() functions which allow you to replace many for loops with code that is both more succinct and easier to read.\n> \n> [purrr docs](https://purrr.tidyverse.org/)\n\n## The `map_*()` functions\n\n1. Take a vector as input\n2. Apply a function to each element\n3. Return a new vector \n\n##  The `map_*()` functions\n\nWe say \"functions\" because there are 5, one for each type of vector: \n\n- `map()` - list\n- `map_lgl()` - logical\n- `map_int()` - integer\n- `map_dbl()` - double\n- `map_chr()` - character\n\n## `map` use case\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(\n    x = 1:10,\n    y = 11:20,\n    z = 21:30\n)\n```\n:::\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\nwith copy+paste\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(df$x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.5\n```\n:::\n\n```{.r .cell-code}\nmean(df$y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15.5\n```\n:::\n\n```{.r .cell-code}\nmean(df$z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25.5\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\nwith `map`\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(df, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$x\n[1] 5.5\n\n$y\n[1] 15.5\n\n$z\n[1] 25.5\n```\n:::\n:::\n\n\n:::\n::::\n\n# `tibble`\nmodern data frames\n\n## `tibble`\n\n> A tibble, or tbl_df, is a modern reimagining of the data.frame, keeping what time has proven to be effective, and throwing out what is not. Tibbles are data.frames that are lazy and surly: they do less and complain more\n> \n> [tibble docs](https://tibble.tidyverse.org/)\n\n## `tibble` \n\nTibbles do less than data frames, in a good way: \n\n- never changes type of input (never converts strings to factors!)\n- never changes the name of variables \n- only recycles vectors of length 1\n- never creates row names \n\n\n::: aside\nThe take-away is that `data.frame` and `tibble` sometimes behave differently. The behavior of `tibble` makes more sense for modern data science, so we should us it instead!\n:::\n\n## Create a `tibble` {.smaller}\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\nCoerce an existing object:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(\n    x = 1:4,\n    y = c(\"a\", \"b\", \"c\", \"d\")\n)\nas_tibble(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n      x y    \n  <int> <chr>\n1     1 a    \n2     2 b    \n3     3 c    \n4     4 d    \n```\n:::\n:::\n\n\nPass a column of vectors: \n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n    x = 1:4,\n    y = c(\"a\", \"b\", \"c\", \"d\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n      x y    \n  <int> <chr>\n1     1 a    \n2     2 b    \n3     3 c    \n4     4 d    \n```\n:::\n:::\n\n\n\n:::\n::: {.column width=\"50%\"}\n\nDefine row-by-row:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntribble(\n    ~x, ~y,\n    \"a\", 1,\n    \"b\", 2,\n    \"c\", 3,\n    \"d\", 4 \n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n  x         y\n  <chr> <dbl>\n1 a         1\n2 b         2\n3 c         3\n4 d         4\n```\n:::\n:::\n\n\n:::\n::::\n\n## Test if `tibble`\n\nWith `is_tibble(x)` and `is.data.frame(x)`\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\nData frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(\n    x = 1:4,\n    y = c(\"a\", \"b\", \"c\", \"d\")\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis_tibble(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.data.frame(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\n:::\n::: {.column width=\"50%\"}\n\nTibble:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntib <- tribble(\n    ~x, ~y,\n    \"a\", 1,\n    \"b\", 2,\n    \"c\", 3,\n    \"d\", 4 \n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis_tibble(tib)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.data.frame(tib)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n:::\n::::\n\n## `data.frame` v `tibble` {.smaller}\n\nYou will encounter 2 main diffs:\n\n1. **printing** \n    - by default, tibbles print the first 10 rows and all columns that fit on screen, making it easier to work with large datasets. \n    - also report the type of each column (e.g. `<dbl>`, `<chr>`)\n2. **subsetting** - tibbles are more strict than data frames, which fixes two quirks we encountered last lecture when subsetting with `[[` and `$`:\n    - tibbles *never* do partial matching\n    - they *always* generate a warning if the column you are trying to extract does not exist.\n\n# `readr`\nreading data \n\n## `readr`\n\n> The goal of readr is to provide a fast and friendly way to read rectangular data from delimited files, such as comma-separated values (CSV) and tab-separated values (TSV). It is designed to parse many types of data found in the wild, while providing an informative problem report when parsing leads to unexpected results.\n> \n> [readr docs](https://readr.tidyverse.org/)\n\n## Rectangular data\n\n![Sample csv file from R for Data Science](/include/figures/rectangle-data.png){#fig-rectangledata fig-align=\"center\" width=80%}\n\n## `read_*()`\n\nThe `read_*()` functions have two important arguments: \n\n1. `file` - the path to the file \n2. `col_types` - a list of how each column should be converted to a specific data type\n\n## 7 supported file types, `read_*()`\n\n- `read_csv()`: comma-separated values (CSV)\n- `read_tsv()`: tab-separated values (TSV)\n- `read_csv2()`: semicolon-separated values\n- `read_delim()`: delimited files (CSV and TSV are important special cases)\n- `read_fwf()`: fixed-width files\n- `read_table()`: whitespace-separated files\n- `read_log()`: web log files\n\n## Read `csv` files \n\nPath only, `readr` guesses types: \n\n```r\nread_csv(file='\"https://pos.it/r4ds-students-csv\"')\n\n```\n. . .\n\nPath and specify col_types:\n```r\nread_csv(\n    file='\"https://pos.it/r4ds-students-csv\"', \n    col_types = list( x = col_string(), y = col_skip() )\n)\n```\n\n::: aside\nGuessing heuristic: character > date-time > double > logical\n:::\n\n\n## `col_types` column specification {.smaller}\n\nThere are 11 column types that can be specified: \n\n- `col_logical()` - reads as boolean TRUE FALSE values\n- `col_integer()` - reads as integer\n- `col_double()` - reads as double\n- `col_number()` - numeric parser that can ignore non-numbers\n- `col_character()` - reads as strings\n- `col_factor(levels, ordered = FALSE)` - creates factors\n- `col_datetime(format = \"\")` - creates date-times\n- `col_date(format = \"\")` - creates dates\n- `col_time(format = \"\")` - creates times\n- `col_skip()` - skips a column \n- `col_guess()` - tries to guess the column\n\n## Reading more complex files {.smaller}\n\nReading more complex file types requires functions outside the tidyverse:\n\n- **excel** with `readxl` - see [Spreadsheets](https://r4ds.hadley.nz/spreadsheets#excel) in R for Data Science\n- **google sheets**  with `googlesheets4` - see [Spreadsheets](https://r4ds.hadley.nz/spreadsheets#google-sheets) in R for Data Science\n- **databases** with `DBI` - see [Databases](https://r4ds.hadley.nz/databases) in R for Data Science\n- **json data** with `jsonlite` - see [Hierarchical data](https://r4ds.hadley.nz/rectangling) in R for Data Science\n\n## Writing to a file\n\nWrite to a .csv file with\n\n```r\nwrite_csv(students, \"students.csv\")\n```\n\n:::aside\narguments: tibble, name to give file\n:::\n\n# Common problems `readr`\n\n## Column contains unexpected values\n\nYour dataset has a column that you expected to be `logical` or `double`, but there is a typo somewhere, so R has coerced the column into `character`. \n\n. . . \n\nSolve by specifying the column type `col_double()` and then using the `problems()` function to see where R failed.\n\n## Missing values are not `NA`\n \nYour dataset has missing values, but they were not coded as `NA` as R expects. \n\n. . . \n\nSolve by adding an `na` argument (e.g. `na=c(\"N/A\")`)\n\n## Column names have spaces \n\nYour dataset has column names that include spaces, breaking R's naming rules. In these cases, R adds backticks (e.g. `` `brain size` ``); \n . . . \n\nWe can use the `rename()` function to fix them. \n\n::: aside\nIf we have a lot to rename and that gets annoying, see `janitor::clean_names()`.\n:::\n\n\n\n# Questions? \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}