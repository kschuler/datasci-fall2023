{
  "hash": "f4bd1c632f2ec545ddd94a222832f4a9",
  "result": {
    "markdown": "---\nlayout: page\ntitle:  \"R basics\"\ndate:   2023-08-31\nauthor: \n    - Katie Schuler\n    - June Choe\n---\n\n\n## Basics\n\nWe begin by defining some basic concepts:\n\n- **Expressions **are combinations of values, variables, operators, and functions that can be evaluated to produce a result. Expressions can be as simple as a single value or more complex involving calculations, comparisons, and function calls. They are the fundamental building blocks of programming.\n    - `10` - a simple value expression that evaluates to `10`.\n    - `x <- 10` - an expression that assigns the value of `10` to `x`.\n    - `x + 10` - an expression that adds the value of `x` to `10`.\n    - `a <- x + 10` - an expression that adds the value of `x` to `10` and assigns the result to the variable `a`\n- **Ojbects** allow us to store various types of data, such as numbers, text, vectors, matrices; and more complex structures like functions and data frames. Objects are created by assigning values to variable names with the assignment operator, `<-`. For example, in `x <- 10`, `x` is an object assigned to the value 10.\n- **Names** that we assign to objects must include only letters, numbers, `.`, or `_`. Names must start with a letter (or `.` if not followed by a number).\n- **Attributes** allow you to attach arbitrary metadata to an object. For example, adding a `dim` (dimension) attribute to a vector allows it to behave like a matrix or n dimensional array. \n- **Functions** (or commands) are reusable pieces of code that take some input, preform some task or computation, and return an output. Many functions are built-in to base R (see below!), others can be part of packages or even defined by you. Functions are objects!\n- **Environment** is the collection of all the objects (functions, variables etc.) we defined in the current R session.\n- **Packages** are collections of functions, data, and documentation bundled together in R. They  enhance R's capabilities by introducing new functions and specialized data structures. Packages need to be installed and loaded before you can use their functions or data. \n- **Comments** are notes you leave to yourself (within code blocks in colab) to document your code; comments are not evaluated.\n- **Messages** are notes R leaves for you, after you run your code. Messages can be simply for-your-information, warnings that something unexpected might happen, or erros if R cannot evaluate your code.\n\nWays to get help when coding in R:\n\n- **Read package docs** - packages usually come with extensive documentation and examples. Reading the docs is one of the best ways to figure things out. Here is an example from the [dplyr package](https://dplyr.tidyverse.org/).\n- **Read error messages** - read any error messages you receive while coding — they give clues about what is going wrong! \n- **Ask R** - Use R's built-in functions to get help as you code\n- **Ask on Ed** - ask questions on our class discussion board!\n- **Ask Google or Stack Overflow** - It is a normal and important skill (not cheating) to google things while coding and learning to code! Use keywords and package names to ensure your solutions are course-relevant.\n- **Ask ChatGPT** - You can similarly use ChatGPT or other LLMs as a resource. But keep in mind they may provide a solution that is wrong or not relevant to what we are learning in this course.\n\n## Important functions\n\nFor objects: \n\n- `str(x)` - returns summary of object's structure\n- `typeof(x)` - returns object's data type\n- `length(x)` - returns object's length\n- `attributes(x)` - returns list of object's attributes\n\nFor environment: \n\n- `ls()` - list all variables in environment\n- `rm(x)` - remove x variable from environment\n- `rm(list = ls())` - remove all variables from environment\n\nFor packages: \n\n- `install.packages()` to install packages\n- `library()` to load the package into your current R session.\n- `data()` to load data from package into environment\n- `sessionInfo()` - version information for current R session and packages\n\nFor help:\n\n- `?mean` - get help with a function\n- `help('mean')` - search help files for word or phrase\n- `help(package='tidyverse')` - find help for a package \n\n\n## Vectors\n\nOne of the must fundamental data structures in R is the **vector**. There are two types:\n\n- **atomic vector** - elements of the same data type\n- **list** - elements refer to any object (even complex objects or other lists)\n\nAtomic vectors can be one of six **data types**:\n\n- `double` - real numbers, written in decimal (0.1234) or scientific notation (1.23e4)\n    - numbers are double by default (3 is stored as 3.00)\n    - three special doubles: `Inf`, `-Inf`, and `NaN` (not a number)\n- `integer` - integers, whole numbers followed by `L` (3L or 1e3L)\n- `character` - strings with single or double quotes ('hello world!' or \"hello world!\")\n- `logical` - boolean, written (`TRUE` or `FALSE`) or abbreviated (`T` or `F`)\n- `complex` - complex numbers, where `i` is the imaginary number (`5 + 3i`)\n- `raw` - stores raw bytes\n\nTo create atomic vectors: \n\n- `c(2,4,6)` - `c()` function for combining elements, returns `2 4 6`\n- `2:4` - `:` notation to construct a sequence of integers, returns `2 3 4`\n- `seq(from = 2, to = 6, by=2)` - `seq()` function to create an evenly-spaced sequence, returns `2 4 6`\n\n\nTo check an object's data type:\n\n- `typeof(x)` - returns the data type of object x\n- `is.*(x)` - test if object x is data type, returns `TRUE` or `FALSE`\n    - `is.double()`\n    - `is.integer()`\n    - `is.character()`\n    - `is.logical()`\n\nTo change an object to data type (**explicit coercion**):\n\n- `as.*(x)` - coerce object to data type \n    - `as.double()`\n    - `as.integer()`\n    - `as.character()`\n    - `as.logical()`\n\nNote that atomic vectors must contain only elements of the same type. If you try to include elements of different types, R will coerce them into the same type with no warning (**implicit coercion**) where:\n\n-  character > double > integer > logical \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# example of implicit coercion\nx <- c(1, \"two\", 3)\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n    \n\n## Operations\n\nArithmetic operators:\n\n- `+` - add \n- `-` - subtract\n- `*` - multiply\n- `/` - divide\n- `^` - exponent\n\nComparison operators return true or false:\n\n- `a == b` - equal to\n- `a != b` - not equal to \n- `a > b` - greater than\n- `a < b` - less than\n- `a >= b` - greater than or equal to\n- `a <= b ` - less than or equal to\n\nLogical operators combine multiple true or false statements:\n\n- `&` - and\n- `|` - or\n- `!` - not\n- `any()` - returns true if any element meets condition\n- `all()` - returns true if all elements meet condition\n- `%in%` - returns true if any element is in the following vector\n\nMost math operations (and many functions) are **vectorized** in R:\n\n- they can work on entire vectors, without the need for explicit loops or iteration.\n- this a powerful feature that allows you to write cleaner, more efficient code\n- To illustrate, suppose `x <- c(1, 2, 3)`:\n    - `x + 100` returns `c(101, 102, 103)`\n    - `x == 1` returns `c(TRUE, FALSE, FALSE)`\n\n\n\n## More complex structures \n\nSome more complex data structures are **built from atomic vectors** by adding **attributes**:\n\n- `matrix` - a vector with a `dim` attribute representing 2 dimensions\n- `array` - a vector with a `dim` attribute representing n dimensions\n- `factor` - an integer vector with two attributes: `class=\"factor\"` and `levels`, which defines the set of allowed values (useful for categorical data)\n- `date-time` - a double vector where the value is the number of seconds since Jan 01, 1970 and a `tzone` attribute representing the time zone\n- `data.frame` - a named list of vectors (of equal length) with attributes for `names` (column names), `row.names`, and `class=\"data.frame\"` (used to represent datasets)\n\nTo create more complex structures: \n\n- `list(x=c(1,2,3), y=c('a','b'))` - create a list\n- `matrix(x, nrow=2, ncol=2)` - create a matrix from a vector `x` with nrow and ncol\n- `array(x, dim=c(2,3,2))` - create an array from a vector `x` with dimensions \n- `factor(x, levels=unique(x))` - turn a vector `x` into a factor \n- `data.frame(x=c(1,2,3), y=c('a','b','c'))` - create a data frame\n\nMissing elements and empty vectors: \n\n- `NA`- used to represent missing or unknown elements in vectors. Note that `NA` is contageous: expressions including `NA` usually return `NA`. Check for `NA` values with `is.na()`.\n- `NULL` - used to represent an empty or absent vector of arbitrary type. `NULL` is its own special type and always has length zero and `NULL` attributes. Check for `NULL` values with `is.null()`.\n\n\n## Subsetting\n\n> Subsetting is a natural complement to str(). While str() shows you all the pieces of any object (its structure), subsetting allows you to pull out the pieces that you’re interested in. ~ Hadley Wickham, Advanced R\n\nThere are three operators for subsetting objects: \n\n- `[` - *subsets* (one or more) elements\n- `[[` and `$` - *extracts* a single element  \n\nThere are six ways to **subset multiple elements** from vectors with `[`:\n\n- `x[c(1,2)]` - positive integers select elements at specified indexes\n- `x[-c(1,2)]` - negative integers select all but elements at specified indexes\n- `x[c(\"name\", \"name2\")]` select elements by name, if elements are named\n- `x[]` - nothing returns the original object\n- `x[0]` - zero returns a zero-length vector\n- `x[c(TRUE, TRUE)]` - select elements where corresponding logical value is `TRUE`\n\nThese also apply when selecting multiple elements from **higher dimensional objects** (matrix, array, data frame), but note that:\n\n- indexes for different dimensions are separated by commas `[rows, columns, ...]`\n- omitted dimensions return all values along that dimension\n- the result is simplified to the lowest possible dimensions by default\n- they can also be indexed like a vector (selects columns)\n\nThere are 3 ways to **extract a single element** from any data structure: \n\n- `[[2]]` - a single positive integer (index)\n- `[['name']]` - a single string \n- `x$name` - the `$` operator is a useful shorthand for `[['name']]`\n\nWhen extracting single elements, note that: \n\n- `[[` is preferred for atomic vectors for clarity (though`[` also works)\n- `$` does partial matching without warning; use `options(warnPartialMatchDollar=TRUE)`\n- the behavior for invalid indexes is inconsistent:\nsometimes you'll get an error message, and sometimes it will return `NULL`\n\n\n## Built-in functions \n\nNote that you do not need to memorize these built-in functions to be successful on quizzes. Use this as a reference. \n\nFor basic math:\n\n- `log(x)` - natural log \n- `exp(x)` - exponential \n- `sqrt(x)` - square root \n- `abs(x)` - absolute value\n- `max(x)` - largest element\n- `min(x)` - smallest element \n- `round(x, n)` - round to n decimal places \n- `signif(x, n)` - round to n significant figures \n- `sum(x)` - add all elements\n\nFor stats: \n\n- `mean(x)` - mean\n- `median(x)` - median\n- `sd(x)` - standard deviation\n- `var(x)` - variance\n- `quantile(x)` - percentage quantiles\n- `rank(x)` - rank of elements\n- `cor(x, y)` - correlation\n- `lm(x ~ y, data=df)` - fit a linear model\n- `glm(x ~ y, data=df)` - fit a generalized linear model\n- `summary(x)` - get more detailed information from a fitted model\n- `aov(x)` - analysis of variance \n\nFor vectors: \n\n- `sort(x)` - return sorted vector\n- `table(x)` - see counts of values in a vector\n- `rev(x)` - return reversed vector\n- `unique(x)` - return unique values in a vector\n- `array(x, dim)` - transform vector into n-dimensional array\n\nFor matrices: \n\n- `t(m)` - transpose matrix\n- `m %+% n` - matrix multiplication\n- `solve(m, n)` - find x in m * x = n\n\nFor data frames: \n\n- `view(df)` - see the full data frame\n- `head(df)` - see the first 6 rows of data frame\n- `nrow(df)` - number of rows in a data frame\n- `ncol(df)` - number of columns in a data frame\n- `dim(df)` - number of rows and columns in a data frame \n- `cbind(df1, df2)` - bind dataframe columns \n- `rbind(df1, df2)` - bind dataframe rows\n\nFor strings:\n\n- `paste(x, y, sep=' ')` - join vectors together element-wise\n- `toupper(x)` - convert to uppercase\n- `tolower(x)` - convert to lowercase\n- `nchar(x)` - number of characters in a string\n\nFor simple plotting:\n\n- `plot(x)` values of x in order\n- `plot(x, y)` - values of x against y\n- `hist(x)` - histogram of x\n\n## Programming in R\n\nWriting **functions** and handling **control flow** are important aspects of learning to program in any language. For our purposes, some general conceptual knowledge on these topics is sufficient (see below). Those interested to learn more might enjoy the book [Hands-On Programming with R](https://rstudio-education.github.io/hopr/). \n\n\n- **Functions** are reusable pieces of code that take some input, perform some task or computation, and return an output. \n\n    ```r\n    function(inputs){\n        # do something\n        return(output)\n    }\n    ```\n    \n- **Control flow** refers to managing the order in which expressions are executed in a program: \n    - `if`...`else` - if something is true, do this; otherwise do that\n    - `for` loops - repeat code a specific number of times \n    - `while` loops - repeat code as long as certain conditions are true\n    - `break` - exit a loop early\n    - `next` - skip to next iteration in a loop \n\n\n## Further reading and references\n\nSuggested further reading:\n\n- [Base R Cheat Sheet](https://iqss.github.io/dss-workshops/R/Rintro/base-r-cheat-sheet.pdf)\n- [R Nuts and Bolts](https://bookdown.org/rdpeng/rprogdatascience/r-nuts-and-bolts.html) in R Programming for Data Science by Roger Peng\n\nOther references: \n\n- [Vectors](https://adv-r.hadley.nz/vectors-chap.html) in Advanced R by Hadley Wickham\n- [Subsetting](https://adv-r.hadley.nz/subsetting.html) in Advanced R by Hadley Wickham\n- [A field guide to base R](https://r4ds.hadley.nz/base-r) in R for Data Science by Hadley Wickham\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}