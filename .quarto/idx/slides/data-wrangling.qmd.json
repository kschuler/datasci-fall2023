{"title":"Data wrangling","markdown":{"yaml":{"title":"Data wrangling","subtitle":"Data Science for Studying Language and the Mind","author":"Katie Schuler","date":"09-14-2023","echo":true,"format":{"revealjs":{"theme":"dark","slide-number":true,"incremental":true,"footer":"[https://kathrynschuler.com/datasci](https://kathrynschuler.com/datasci/)"}}},"headingText":"You are `here`","headingAttr":{"id":"","classes":["smaller"],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n```{r}\n#| echo: false\nlibrary(tidyverse)\nlibrary(languageR)\n```\n\n\n:::: {.columns}\n\n::: {.column width=\"33%\"}\n\n##### Data science with R \n::: {.nonincremental}\n- Hello, world!\n- R basics\n- Data importing\n- Data visualization\n- `Data wrangling` \n:::\n:::\n\n::: {.column width=\"33%\"}\n\n##### Stats & Model building\n::: {.nonincremental}\n- Probability distributions\n- Sampling variability\n- Hypothesis testing\n- Model specification\n- Model fitting \n- Model accuracy\n- Model reliability\n:::\n:::\n\n::: {.column width=\"33%\"}\n\n##### More advanced \n::: {.nonincremental}\n\n- Classification\n- Feature engineering (preprocessing) \n- Inference for regression\n- Mixed-effect models\n::: \n:::\n\n::::\n\n# Acknowledgements\n\nR for Data Science, Ch 4\n\n## Why wrangle? \n\n> Visualization is an important tool for generating insight, but it’s rare that you get the data in exactly the right form you need to make the graph you want. Often you’ll need to create some new variables or summaries to answer your questions with your data, or maybe you just want to rename the variables or reorder the observations to make the data a little easier to work with.\n\n\n# `dplyr` \n\n## Common structure of `dplyr` verbs \n\nAll `dplyr` functions (verbs) share a common structure:\n\n- 1st argument is always a data frame\n- Subsequent arguments typically describe which columns to operate on (via their names) \n- Output is always a new data frame\n\n## Some `dplyr` verbs operate on {.smaller}\n\n- rows - see section 3 Manipulating rows\n- columns - see section 4 Manipulating columns\n- groups - see section 5 Grouping and summarizing data frames\n- tables - see section 6 Joining data frames\n\n## Combine `dplyr` verbs with the pipe\n\nWe can easily combine `dplyr` functions to solve complex problems:\n\n- The pipe operator, `|>` takes the output from one function and passes it as input (the first argument) to the next function.\n- There is another version of the pipe, `%>%`. See the reading on data transformation if you are curious about the difference. \n\n# Rows\n\n## Manipualate rows with `dplyr` \n\n| | |\n| --- | ------- | \n| `filter()` | keep only some rows based on values of column |\n| `arrange()` | arrange rows in order you specify |\n| `distinct()` | finds unique rows | \n\n\n\n## `fliter()` {.smaller}\n\nKeep only some rows based on values of the column using logical operations\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec:Word) %>%\n    filter(Familiarity < 3.0)\n\n```\n\n## `fliter()` {.smaller}\n\n\n\n:::: {.columns}\n\n::: {.column width=50%}\n\nCommon mistake is using `=` \n\n\n```{r}\n#| echo: true\n#| error: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec:Word) %>%\n    filter(Word = 'zoo')\n\n```\n\n::: \n\n::: {.column width=50%}\n\ninstead of `==`\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec:Word) %>%\n     filter(Word == 'zoo')\n\n```\n\n::: \n\n::::\n\n## `arrange()` {.smaller}\n\nArranges rows in the order you specify \n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec:Word) %>%\n    arrange(Word)\n\n```\n\n## `arrange()` {.smaller}\n\n\n:::: {.columns}\n\n::: {.column width=50%}\n\nWill use ascending order\n\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec:Word) %>%\n    arrange(Word)\n\n```\n\n::: \n\n::: {.column width=50%}\n\nUnless you specify descending \n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec:Word) %>%\n    arrange(desc(Word))\n\n```\n\n::: \n\n::::\n\n## `distinct()` {.smaller}\n\nFinds unique rows in a dataset; no arguments removes duplicates in dataset (if any exist)\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec:Word) %>%\n    distinct(Word)\n\n```\n\n## `distinct()` {.smaller}\n\nYou can optionally specify columns to find unique combinations \n\n:::: {.columns}\n\n::: {.column width=50%}\n\nReturns only the columns you specify\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec:Word) %>%\n    distinct(Word)\n\n```\n\n::: \n\n::: {.column width=50%}\n\nUnless you add `.keep_all=TRUE` argument\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec:Word) %>%\n    distinct(Word, .keep_all=TRUE)\n\n```\n\n::: \n\n::::\n\n\n\n\n\n\n# Columns\n\n## Manipualate columns with `dplyr` \n\n| | |\n| --- | ------- | \n| `mutate()` | adds new columns calculated from existing columns |\n| `select()` | selects columns based on their names |\n| `rename()` | renames some columns | \n\n\n\n\n## `select()` {.smaller}\n\nSelect columns based on their names \n\n```{r}\n#| echo: true\n#| code-line-numbers: \"2\"\nenglish %>%  \n    select(RTlexdec, Familiarity, AgeSubject)\n\n```\n\n\n## `select()` {.smaller}\n\nUse `:` to select everything from one column to another\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"2\"\nenglish %>%  \n    select(RTlexdec:AgeSubject)\n\n```\n\n## `select()` {.smaller}\n\nUse logical operators like `&` or `!` to identify the subset of columns you want to select\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"2\"\nenglish %>%  \n    select(!RTlexdec:AgeSubject)\n\n```\n\n## `select()` {.smaller}\n\nYou can rename columns when you select them\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"2\"\nenglish %>%  \n    select(RTlex = RTlexdec, Familiarity, AgeSubject)\n\n```\n\n## `rename()` {.smaller}\n\nKeep all columns but rename one or more\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"2\"\nenglish %>%  \n    rename(RTlex = RTlexdec, WordCat = WordCategory)\n\n```\n\n## `mutate()` {.smaller}\n\nAdd new columns that are calculated from exising columns \n\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec:AgeSubject) %>%\n    mutate(RTdiff = RTlexdec - RTnaming)\n\n```\n\n\n## `mutate()` {.smaller}\n\nColumns are added to the right by default, but you can specify where you'd like to add them by number or name \n\n:::: {.columns}\n\n::: {.column width=50%}\n\nWith `.after` \n\n```{r}\n#| echo: true\n#| code-line-numbers: \"5\"\nenglish %>%  \n    select(RTlexdec:Familiarity) %>%\n    mutate(\n        RTdiff = RTlexdec - RTnaming,\n        .after = RTnaming\n    )\n\n```\n\n::: \n\n::: {.column width=50%}\n\nWith `.before` \n\n```{r}\n#| echo: true\n#| code-line-numbers: \"5\"\nenglish %>%  \n    select(RTlexdec:Familiarity) %>%\n    mutate(\n        RTdiff = RTlexdec - RTnaming,\n        .before = RTlexdec\n    )\n\n```\n\n::: \n\n::::\n\n\n# Group and summarise \n\n## Group and summarise with `dplyr` \n\n| | |\n| --- | ------- | \n| `group_by()` | used to divide your dataset into groups |\n| `summarise()` | often used after `group_by()` to calculate summary statistics on grouped data |\n| `ungroup()` | used to remove the grouping | \n\n## `group_by()` {.smaller}\n\nDivide your dataset into groups \n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec, Familiarity, AgeSubject) %>%\n    group_by(AgeSubject)\n\n```\n\n## `group_by()` {.smaller}\n\nCan group by more than one variable\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec, Familiarity, AgeSubject, Voice) %>%\n    group_by(AgeSubject, Voice)\n\n```\n\n## `group_by()` {.smaller}\n\nDoes not change original df, adds groups attribute\n\n\n:::: {.columns}\n\n::: {.column width=50%}\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\ngrouped_english <- english %>%  \n    select(RTlexdec, Familiarity, AgeSubject) %>%\n    group_by(AgeSubject)\n\ngrouped_english\n```\n\n::: \n\n::: {.column width=50%}\n\n\n```{r}\nattr(english, \"groups\")\n```\n\n```{r}\nattr(grouped_english, \"groups\")\n```\n\n::: \n\n::::\n\n\n. . . \n\n\n## `summarise()` {.smaller}\n\nOften used after `group_by()` to calculate summary stats on grouped data \n\n```{r}\n#| echo: true\n#| code-line-numbers: \"4\"\nsummary_english <- english %>%  \n    select(RTlexdec, Familiarity, AgeSubject) %>%\n    group_by(AgeSubject) %>%\n    summarise(n = n())\n\nsummary_english\n```\n\n## `summarise()` {.smaller}\n\nYou can add any number of summary stats \n\n```{r}\n#| echo: true\n#| code-line-numbers: \"5-6\"\nsummary_english <- english %>%  \n    select(RTlexdec, Familiarity, AgeSubject, Voice) %>%\n    group_by(AgeSubject, Voice) %>%\n    summarise(\n        n = n(), \n        mean = mean(RTlexdec)\n    )\n\nsummary_english\n```\n\n- Note that the returned dataframe is grouped!\n\n## `summarise()` {.smaller}\n\nUse the `.groups` argument to drop or keep grouping in returned dataframe\n\n:::: {.columns}\n\n::: {.column width=50%}\n\nDrop all groups\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"7\"\nsummary_english <- english %>%  \n    select(RTlexdec, Familiarity, AgeSubject, Voice) %>%\n    group_by(AgeSubject, Voice) %>%\n    summarise(\n        n = n(), \n        mean = mean(RTlexdec), \n        .groups = \"drop\"\n    )\n\nsummary_english\n```\n\n::: \n\n::: {.column width=50%}\n\nKeep all groups\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"7\"\nsummary_english <- english %>%  \n    select(RTlexdec, Familiarity, AgeSubject, Voice) %>%\n    group_by(AgeSubject, Voice) %>%\n    summarise(\n        n = n(), \n        mean = mean(RTlexdec), \n        .groups = \"keep\"\n    )\n\nsummary_english\n```\n\n::: \n\n::::\n\n## `summarise()`  {.smaller}\n\nOr use the new `.by` argument **instead of** group_by() to return an ungrouped dataframe\n\n:::: {.columns}\n\n::: {.column width=50%}\n\nDrop all groups\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3,7\"\nsummary_english <- english %>%  \n    select(RTlexdec, Familiarity, AgeSubject, Voice) %>%\n    group_by(AgeSubject, Voice) %>%\n    summarise(\n        n = n(), \n        mean = mean(RTlexdec), \n        .groups = \"drop\"\n    )\n\nsummary_english\n```\n\n::: \n\n::: {.column width=50%}\n\nOr just use by!\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"6\"\nsummary_english <- english %>%  \n    select(RTlexdec, Familiarity, AgeSubject, Voice) %>%\n    summarise(\n        n = n(), \n        mean = mean(RTlexdec), \n        .by = c(AgeSubject, Voice)\n    )\n\nsummary_english\n```\n\n::: \n\n::::\n\n\n## `ungroup()`  {.smaller}\n\nCan also remove grouping after with `ungroup()`\n\n:::: {.columns}\n\n::: {.column width=50%}\n\nDrop all groups\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"7\"\nsummary_english <- english %>%  \n    select(RTlexdec, Familiarity, AgeSubject, Voice) %>%\n    group_by(AgeSubject, Voice) %>%\n    summarise(\n        n = n(), \n        mean = mean(RTlexdec), \n        .groups = \"drop\"\n    )\n\nsummary_english\n```\n\n::: \n\n::: {.column width=50%}\n\nOr ungroup after\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"8\"\nsummary_english <- english %>%  \n    select(RTlexdec, Familiarity, AgeSubject, Voice) %>%\n    summarise(\n        n = n(), \n        mean = mean(RTlexdec), \n        .by = c(AgeSubject, Voice)\n    ) %>% \n    ungroup()\n\nsummary_english\n```\n\n::: \n\n::::\n\n\n\n# More advanced \n\n## Not covered, but good to know\n\nThere are a few more advanced techniques for transforming and tidying data that we won't cover now, but might be useful to you in your own research.\n\n- **joins** - sometimes you have more than one dataset that you want to join into one. `dplyr` also has functions for handling that. [Learn more about joins](https://r4ds.hadley.nz/joins)\n- **pivots** - sometimes your data doesn't arrive in the tidy data form.  The `tidyr` package can help with  `pivot_longer()` and `pivot_wider()`. [Learn more about pivots](https://r4ds.hadley.nz/data-tidy)","srcMarkdownNoYaml":"\n\n```{r}\n#| echo: false\nlibrary(tidyverse)\nlibrary(languageR)\n```\n\n## You are `here` {.smaller} \n\n:::: {.columns}\n\n::: {.column width=\"33%\"}\n\n##### Data science with R \n::: {.nonincremental}\n- Hello, world!\n- R basics\n- Data importing\n- Data visualization\n- `Data wrangling` \n:::\n:::\n\n::: {.column width=\"33%\"}\n\n##### Stats & Model building\n::: {.nonincremental}\n- Probability distributions\n- Sampling variability\n- Hypothesis testing\n- Model specification\n- Model fitting \n- Model accuracy\n- Model reliability\n:::\n:::\n\n::: {.column width=\"33%\"}\n\n##### More advanced \n::: {.nonincremental}\n\n- Classification\n- Feature engineering (preprocessing) \n- Inference for regression\n- Mixed-effect models\n::: \n:::\n\n::::\n\n# Acknowledgements\n\nR for Data Science, Ch 4\n\n## Why wrangle? \n\n> Visualization is an important tool for generating insight, but it’s rare that you get the data in exactly the right form you need to make the graph you want. Often you’ll need to create some new variables or summaries to answer your questions with your data, or maybe you just want to rename the variables or reorder the observations to make the data a little easier to work with.\n\n\n# `dplyr` \n\n## Common structure of `dplyr` verbs \n\nAll `dplyr` functions (verbs) share a common structure:\n\n- 1st argument is always a data frame\n- Subsequent arguments typically describe which columns to operate on (via their names) \n- Output is always a new data frame\n\n## Some `dplyr` verbs operate on {.smaller}\n\n- rows - see section 3 Manipulating rows\n- columns - see section 4 Manipulating columns\n- groups - see section 5 Grouping and summarizing data frames\n- tables - see section 6 Joining data frames\n\n## Combine `dplyr` verbs with the pipe\n\nWe can easily combine `dplyr` functions to solve complex problems:\n\n- The pipe operator, `|>` takes the output from one function and passes it as input (the first argument) to the next function.\n- There is another version of the pipe, `%>%`. See the reading on data transformation if you are curious about the difference. \n\n# Rows\n\n## Manipualate rows with `dplyr` \n\n| | |\n| --- | ------- | \n| `filter()` | keep only some rows based on values of column |\n| `arrange()` | arrange rows in order you specify |\n| `distinct()` | finds unique rows | \n\n\n\n## `fliter()` {.smaller}\n\nKeep only some rows based on values of the column using logical operations\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec:Word) %>%\n    filter(Familiarity < 3.0)\n\n```\n\n## `fliter()` {.smaller}\n\n\n\n:::: {.columns}\n\n::: {.column width=50%}\n\nCommon mistake is using `=` \n\n\n```{r}\n#| echo: true\n#| error: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec:Word) %>%\n    filter(Word = 'zoo')\n\n```\n\n::: \n\n::: {.column width=50%}\n\ninstead of `==`\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec:Word) %>%\n     filter(Word == 'zoo')\n\n```\n\n::: \n\n::::\n\n## `arrange()` {.smaller}\n\nArranges rows in the order you specify \n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec:Word) %>%\n    arrange(Word)\n\n```\n\n## `arrange()` {.smaller}\n\n\n:::: {.columns}\n\n::: {.column width=50%}\n\nWill use ascending order\n\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec:Word) %>%\n    arrange(Word)\n\n```\n\n::: \n\n::: {.column width=50%}\n\nUnless you specify descending \n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec:Word) %>%\n    arrange(desc(Word))\n\n```\n\n::: \n\n::::\n\n## `distinct()` {.smaller}\n\nFinds unique rows in a dataset; no arguments removes duplicates in dataset (if any exist)\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec:Word) %>%\n    distinct(Word)\n\n```\n\n## `distinct()` {.smaller}\n\nYou can optionally specify columns to find unique combinations \n\n:::: {.columns}\n\n::: {.column width=50%}\n\nReturns only the columns you specify\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec:Word) %>%\n    distinct(Word)\n\n```\n\n::: \n\n::: {.column width=50%}\n\nUnless you add `.keep_all=TRUE` argument\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec:Word) %>%\n    distinct(Word, .keep_all=TRUE)\n\n```\n\n::: \n\n::::\n\n\n\n\n\n\n# Columns\n\n## Manipualate columns with `dplyr` \n\n| | |\n| --- | ------- | \n| `mutate()` | adds new columns calculated from existing columns |\n| `select()` | selects columns based on their names |\n| `rename()` | renames some columns | \n\n\n\n\n## `select()` {.smaller}\n\nSelect columns based on their names \n\n```{r}\n#| echo: true\n#| code-line-numbers: \"2\"\nenglish %>%  \n    select(RTlexdec, Familiarity, AgeSubject)\n\n```\n\n\n## `select()` {.smaller}\n\nUse `:` to select everything from one column to another\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"2\"\nenglish %>%  \n    select(RTlexdec:AgeSubject)\n\n```\n\n## `select()` {.smaller}\n\nUse logical operators like `&` or `!` to identify the subset of columns you want to select\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"2\"\nenglish %>%  \n    select(!RTlexdec:AgeSubject)\n\n```\n\n## `select()` {.smaller}\n\nYou can rename columns when you select them\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"2\"\nenglish %>%  \n    select(RTlex = RTlexdec, Familiarity, AgeSubject)\n\n```\n\n## `rename()` {.smaller}\n\nKeep all columns but rename one or more\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"2\"\nenglish %>%  \n    rename(RTlex = RTlexdec, WordCat = WordCategory)\n\n```\n\n## `mutate()` {.smaller}\n\nAdd new columns that are calculated from exising columns \n\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec:AgeSubject) %>%\n    mutate(RTdiff = RTlexdec - RTnaming)\n\n```\n\n\n## `mutate()` {.smaller}\n\nColumns are added to the right by default, but you can specify where you'd like to add them by number or name \n\n:::: {.columns}\n\n::: {.column width=50%}\n\nWith `.after` \n\n```{r}\n#| echo: true\n#| code-line-numbers: \"5\"\nenglish %>%  \n    select(RTlexdec:Familiarity) %>%\n    mutate(\n        RTdiff = RTlexdec - RTnaming,\n        .after = RTnaming\n    )\n\n```\n\n::: \n\n::: {.column width=50%}\n\nWith `.before` \n\n```{r}\n#| echo: true\n#| code-line-numbers: \"5\"\nenglish %>%  \n    select(RTlexdec:Familiarity) %>%\n    mutate(\n        RTdiff = RTlexdec - RTnaming,\n        .before = RTlexdec\n    )\n\n```\n\n::: \n\n::::\n\n\n# Group and summarise \n\n## Group and summarise with `dplyr` \n\n| | |\n| --- | ------- | \n| `group_by()` | used to divide your dataset into groups |\n| `summarise()` | often used after `group_by()` to calculate summary statistics on grouped data |\n| `ungroup()` | used to remove the grouping | \n\n## `group_by()` {.smaller}\n\nDivide your dataset into groups \n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec, Familiarity, AgeSubject) %>%\n    group_by(AgeSubject)\n\n```\n\n## `group_by()` {.smaller}\n\nCan group by more than one variable\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\nenglish %>%  \n    select(RTlexdec, Familiarity, AgeSubject, Voice) %>%\n    group_by(AgeSubject, Voice)\n\n```\n\n## `group_by()` {.smaller}\n\nDoes not change original df, adds groups attribute\n\n\n:::: {.columns}\n\n::: {.column width=50%}\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3\"\ngrouped_english <- english %>%  \n    select(RTlexdec, Familiarity, AgeSubject) %>%\n    group_by(AgeSubject)\n\ngrouped_english\n```\n\n::: \n\n::: {.column width=50%}\n\n\n```{r}\nattr(english, \"groups\")\n```\n\n```{r}\nattr(grouped_english, \"groups\")\n```\n\n::: \n\n::::\n\n\n. . . \n\n\n## `summarise()` {.smaller}\n\nOften used after `group_by()` to calculate summary stats on grouped data \n\n```{r}\n#| echo: true\n#| code-line-numbers: \"4\"\nsummary_english <- english %>%  \n    select(RTlexdec, Familiarity, AgeSubject) %>%\n    group_by(AgeSubject) %>%\n    summarise(n = n())\n\nsummary_english\n```\n\n## `summarise()` {.smaller}\n\nYou can add any number of summary stats \n\n```{r}\n#| echo: true\n#| code-line-numbers: \"5-6\"\nsummary_english <- english %>%  \n    select(RTlexdec, Familiarity, AgeSubject, Voice) %>%\n    group_by(AgeSubject, Voice) %>%\n    summarise(\n        n = n(), \n        mean = mean(RTlexdec)\n    )\n\nsummary_english\n```\n\n- Note that the returned dataframe is grouped!\n\n## `summarise()` {.smaller}\n\nUse the `.groups` argument to drop or keep grouping in returned dataframe\n\n:::: {.columns}\n\n::: {.column width=50%}\n\nDrop all groups\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"7\"\nsummary_english <- english %>%  \n    select(RTlexdec, Familiarity, AgeSubject, Voice) %>%\n    group_by(AgeSubject, Voice) %>%\n    summarise(\n        n = n(), \n        mean = mean(RTlexdec), \n        .groups = \"drop\"\n    )\n\nsummary_english\n```\n\n::: \n\n::: {.column width=50%}\n\nKeep all groups\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"7\"\nsummary_english <- english %>%  \n    select(RTlexdec, Familiarity, AgeSubject, Voice) %>%\n    group_by(AgeSubject, Voice) %>%\n    summarise(\n        n = n(), \n        mean = mean(RTlexdec), \n        .groups = \"keep\"\n    )\n\nsummary_english\n```\n\n::: \n\n::::\n\n## `summarise()`  {.smaller}\n\nOr use the new `.by` argument **instead of** group_by() to return an ungrouped dataframe\n\n:::: {.columns}\n\n::: {.column width=50%}\n\nDrop all groups\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"3,7\"\nsummary_english <- english %>%  \n    select(RTlexdec, Familiarity, AgeSubject, Voice) %>%\n    group_by(AgeSubject, Voice) %>%\n    summarise(\n        n = n(), \n        mean = mean(RTlexdec), \n        .groups = \"drop\"\n    )\n\nsummary_english\n```\n\n::: \n\n::: {.column width=50%}\n\nOr just use by!\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"6\"\nsummary_english <- english %>%  \n    select(RTlexdec, Familiarity, AgeSubject, Voice) %>%\n    summarise(\n        n = n(), \n        mean = mean(RTlexdec), \n        .by = c(AgeSubject, Voice)\n    )\n\nsummary_english\n```\n\n::: \n\n::::\n\n\n## `ungroup()`  {.smaller}\n\nCan also remove grouping after with `ungroup()`\n\n:::: {.columns}\n\n::: {.column width=50%}\n\nDrop all groups\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"7\"\nsummary_english <- english %>%  \n    select(RTlexdec, Familiarity, AgeSubject, Voice) %>%\n    group_by(AgeSubject, Voice) %>%\n    summarise(\n        n = n(), \n        mean = mean(RTlexdec), \n        .groups = \"drop\"\n    )\n\nsummary_english\n```\n\n::: \n\n::: {.column width=50%}\n\nOr ungroup after\n\n```{r}\n#| echo: true\n#| code-line-numbers: \"8\"\nsummary_english <- english %>%  \n    select(RTlexdec, Familiarity, AgeSubject, Voice) %>%\n    summarise(\n        n = n(), \n        mean = mean(RTlexdec), \n        .by = c(AgeSubject, Voice)\n    ) %>% \n    ungroup()\n\nsummary_english\n```\n\n::: \n\n::::\n\n\n\n# More advanced \n\n## Not covered, but good to know\n\nThere are a few more advanced techniques for transforming and tidying data that we won't cover now, but might be useful to you in your own research.\n\n- **joins** - sometimes you have more than one dataset that you want to join into one. `dplyr` also has functions for handling that. [Learn more about joins](https://r4ds.hadley.nz/joins)\n- **pivots** - sometimes your data doesn't arrive in the tidy data form.  The `tidyr` package can help with  `pivot_longer()` and `pivot_wider()`. [Learn more about pivots](https://r4ds.hadley.nz/data-tidy)"},"formats":{"revealjs":{"identifier":{"display-name":"RevealJS","target-format":"revealjs","base-format":"revealjs"},"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","incremental":true,"output-file":"data-wrangling.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.3.353","auto-stretch":true,"callout-appearance":"simple","title":"Data wrangling","subtitle":"Data Science for Studying Language and the Mind","author":"Katie Schuler","date":"09-14-2023","theme":"dark","slideNumber":true,"footer":"[https://kathrynschuler.com/datasci](https://kathrynschuler.com/datasci/)"}}},"projectFormats":["html"]}